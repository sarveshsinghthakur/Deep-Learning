# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15uVql3V0s5oNwLVaWA1t5QxefjGZrBY9
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
import seaborn as sns
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
from sklearn.preprocessing import label_binarize
from tensorflow.keras.datasets import mnist
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten
from tensorflow.keras.utils import to_categorical
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.applications import ResNet50

(x_train,y_train),(x_test,y_test)=mnist.load_data()

Y_train_new = to_categorical(y_train)
y_test_new = to_categorical(y_test)

#model : CNN
model1 = Sequential([
    Conv2D(32, (3,3), activation='relu', input_shape=(28,28,1)),
    MaxPooling2D(2,2),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(10, activation='softmax')
])

model1.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

model1.fit(x_train,Y_train_new,epochs=5, validation_split=0.1)

y_pred = (model1.predict(x_test).argmax(axis=1))
y_pred1 = np.mean(y_pred==y_test)

print("Accuracy test \n" ,y_pred1*100,"%")

print("Accuracy test \n" ,model1.evaluate(x_test,y_test_new)[1]*100,"%")
print("loss percentage test \n" ,model1.evaluate(x_test,y_test_new)[0]*100,"%")
print("classification report \n" ,classification_report(y_test,y_pred))

cm = confusion_matrix(y_test,y_pred)

plt.figure(figsize=(10, 7))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues")
plt.title("Confusion Matrix")
plt.xlabel("Predicted")
plt.ylabel("True")
plt.show()

fpr = dict()
tpr = dict()
roc_auc = dict()
y_test_bin = label_binarize(y_test, classes=np.arange(10))
y_pred_prob = model1.predict(x_test)
for i in range(10):
    fpr[i], tpr[i], _ = roc_curve(y_test_bin[:, i], y_pred_prob[:, i])
    roc_auc[i] = auc(fpr[i], tpr[i])

plt.figure(figsize=(12, 8))
for i in range(10):
    plt.plot(fpr[i], tpr[i], label=f'Class {i} (AUC = {roc_auc[i]:.2f})')
plt.plot([0, 1], [0, 1], 'k--')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve for Each Digit Class')
plt.legend()
plt.grid(True)
plt.show()

def predict_digit(image_path):
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        print("Image not found.")
        return -1
    img = cv2.resize(img, (28, 28))
    if np.mean(img) > 127:
        img = 255 - img

    img = img / 255.0
    img = img.reshape(1, 28, 28)

    pred = model1.predict(img)
    digit = np.argmax(pred)

    plt.imshow(img.reshape(28, 28), cmap='gray')
    plt.title(f"Predicted Digit: {digit}")
    plt.axis('off')
    plt.show()
    return digit

predicted_digit = predict_digit("Dataset/MNIST_digit.png")

if predicted_digit != -1:
    print(f"Predicted Digit: {predicted_digit}")
else:
    print("Error: Could not predict the digit.")
